{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/snail/source/css/index.css","path":"css/index.css","modified":0,"renderable":1},{"_id":"themes/snail/source/css/layout.css","path":"css/layout.css","modified":0,"renderable":1},{"_id":"themes/snail/source/css/post.css","path":"css/post.css","modified":1,"renderable":1},{"_id":"themes/snail/source/css/reset.css","path":"css/reset.css","modified":0,"renderable":1},{"_id":"themes/snail/source/js/dayjs.min.js","path":"js/dayjs.min.js","modified":0,"renderable":1},{"_id":"themes/snail/source/js/index.js","path":"js/index.js","modified":0,"renderable":1},{"_id":"themes/snail/source/js/layout.js","path":"js/layout.js","modified":0,"renderable":1},{"_id":"themes/snail/source/scss/index.scss","path":"scss/index.scss","modified":0,"renderable":1},{"_id":"themes/snail/source/scss/post.scss","path":"scss/post.scss","modified":1,"renderable":1},{"_id":"themes/snail/source/scss/layout.scss","path":"scss/layout.scss","modified":0,"renderable":1},{"_id":"themes/snail/source/scss/reset.scss","path":"scss/reset.scss","modified":0,"renderable":1}],"Cache":[{"_id":"source/_navs/about.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1688608415377},{"_id":"source/_navs/blogs.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1688608457334},{"_id":"source/_navs/categories.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1688608520466},{"_id":"source/_navs/tags.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1688608503515},{"_id":"source/_posts/.placeholder","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1688704718116},{"_id":"source/_posts/2023-06-01-docker-base.md","hash":"a1584aa1134b5b3aa09650fdbde48dd02a6bb7e0","modified":1688704718120},{"_id":"source/_posts/2023-06-05-docker-compose-clickhouse.md","hash":"b21d912738f55d8ce137a9ee6a40c8adca3e7939","modified":1688704718124},{"_id":"source/_posts/2023-06-05-docker-clickhouse.md","hash":"c8a501f48838d22ef03215ee4d0c64b6c3f4ac82","modified":1688704718120},{"_id":"source/about/index.md","hash":"487ab7c53d5bafaf39a2d686ab3f68736b6f24a9","modified":1688622618913},{"_id":"source/tags/index.md","hash":"a3de2ab29b5dd00301416b3ce80c55a2a5e18161","modified":1688696133176},{"_id":"source/_posts/2023-06-30-Authorization.md","hash":"1cfd060fe67f86f9b8e3a2365a819e4184e6ee5f","modified":1688733121419},{"_id":"themes/snail/layout/archive.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1688609669941},{"_id":"themes/snail/layout/tag.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1688609653865},{"_id":"source/_posts/2023-05-15-hello.md","hash":"231f092f5e3623a7bc689f40278fd0cbfbddf8f6","modified":1688704843708},{"_id":"source/catrgories/index.md","hash":"05bdd3ea44ba03a91db5eeb09dcecbcb093961e4","modified":1688696124268},{"_id":"themes/snail/_config.yml","hash":"e6c909853444d9f6394d89142f3bff82782832a5","modified":1688695380689},{"_id":"themes/snail/layout/catrgories.ejs","hash":"6b521bb1da6de6409ecbe333115569b286896f04","modified":1688730736242},{"_id":"themes/snail/layout/header.ejs","hash":"ac2170476f56688abb49804b880089c9680fdcb1","modified":1688731514439},{"_id":"themes/snail/layout/footer.ejs","hash":"daf951263ee094e189c0fd57fc858e197560a35a","modified":1688707514132},{"_id":"themes/snail/layout/layout.ejs","hash":"cffbc79a27145737babd61f6a7dafa0a06ddc3b9","modified":1688730717987},{"_id":"themes/snail/layout/index.ejs","hash":"d63ff6a7363a8871585d4b49285d79fbdf401176","modified":1688730747618},{"_id":"themes/snail/layout/post.ejs","hash":"ef9d9bac74cc6b83f844dd09b8af5d2e69de5f72","modified":1688730817869},{"_id":"themes/snail/source/css/index.css","hash":"f1dcff497e5a75c943fa61fd304661d07023a9cf","modified":1688707784944},{"_id":"themes/snail/source/css/layout.css","hash":"6496d99ea85fb1003c1bbcdd3f3688dcc585eae5","modified":1688707871120},{"_id":"themes/snail/source/css/post.css","hash":"926e52a6f52d90b7916cebaea87e71c5bdfc9d35","modified":1688735080363},{"_id":"themes/snail/source/css/reset.css","hash":"661acb1b2327e3f3e84e8fc0c4c428f092add5a5","modified":1688704609872},{"_id":"themes/snail/source/js/index.js","hash":"610b886543488c9299d5781ef1ea62eef7d32c2a","modified":1688610065625},{"_id":"themes/snail/source/js/layout.js","hash":"610b886543488c9299d5781ef1ea62eef7d32c2a","modified":1688606295386},{"_id":"themes/snail/source/scss/index.scss","hash":"846907e85f21506e5fcf7784a92c10634b721b47","modified":1688707670336},{"_id":"themes/snail/source/scss/post.scss","hash":"ae0dc9d60dafacd9187a386400ba7830db13a54a","modified":1688735080331},{"_id":"themes/snail/source/js/dayjs.min.js","hash":"fbc3c0c699176264398b1eed7dab87c8c5c56126","modified":1688604907653},{"_id":"themes/snail/source/scss/reset.scss","hash":"e7441d5f0c428294a54dc854a0117087df5abb59","modified":1688703830091},{"_id":"themes/snail/source/scss/layout.scss","hash":"a083f7975374b1300741402c079588377be97602","modified":1688707871088},{"_id":"public/catrgories/index.html","hash":"fbfba84c07b51ff23e50a200d4fc1da3ab284daa","modified":1688733164602},{"_id":"public/about/index.html","hash":"3110e5ef6663e2408827f8c428ba5ef3e0473dfb","modified":1688733164602},{"_id":"public/tags/index.html","hash":"748d1ddaa387567af8deeb9f1d4d2d782fe07942","modified":1688733164602},{"_id":"public/2023/06/30/2023-06-30-Authorization/index.html","hash":"09bc873f61d3bfc32c309f70f9818b3b3ddfb4ed","modified":1688733164602},{"_id":"public/2023/06/05/2023-06-05-docker-compose-clickhouse/index.html","hash":"fcc5c2b58695e8142a74d83e39efbac118589964","modified":1688733164602},{"_id":"public/2023/06/04/2023-06-05-docker-clickhouse/index.html","hash":"77ce100b354d2c41a6c9a2fa2e68f32fa8e24ea2","modified":1688733164602},{"_id":"public/2023/06/01/2023-06-01-docker-base/index.html","hash":"65e68120cdf23eaa84cff52945bb816b68a5bb04","modified":1688733164602},{"_id":"public/2023/05/16/2023-05-15-hello/index.html","hash":"bc801308c99a1b0cd1fa8d9e08317a5616f6b249","modified":1688733164602},{"_id":"public/archives/index.html","hash":"a8f1285c767e9e9426f8fbff4cd9e1e69cd91bc7","modified":1688733164602},{"_id":"public/archives/2023/index.html","hash":"a8f1285c767e9e9426f8fbff4cd9e1e69cd91bc7","modified":1688733164602},{"_id":"public/archives/2023/05/index.html","hash":"a8f1285c767e9e9426f8fbff4cd9e1e69cd91bc7","modified":1688733164602},{"_id":"public/archives/2023/06/index.html","hash":"a8f1285c767e9e9426f8fbff4cd9e1e69cd91bc7","modified":1688733164602},{"_id":"public/categories/文章/index.html","hash":"a8f1285c767e9e9426f8fbff4cd9e1e69cd91bc7","modified":1688733164602},{"_id":"public/categories/文章/docker/index.html","hash":"a8f1285c767e9e9426f8fbff4cd9e1e69cd91bc7","modified":1688733164602},{"_id":"public/categories/文章/随笔/index.html","hash":"a8f1285c767e9e9426f8fbff4cd9e1e69cd91bc7","modified":1688733164602},{"_id":"public/categories/文章/auth/index.html","hash":"a8f1285c767e9e9426f8fbff4cd9e1e69cd91bc7","modified":1688733164602},{"_id":"public/index.html","hash":"5804126ab0cc9571dcb23243a835d5083cbb059b","modified":1688733164602},{"_id":"public/tags/docker/index.html","hash":"a8f1285c767e9e9426f8fbff4cd9e1e69cd91bc7","modified":1688733164602},{"_id":"public/tags/clickhouse/index.html","hash":"a8f1285c767e9e9426f8fbff4cd9e1e69cd91bc7","modified":1688733164602},{"_id":"public/tags/docker-compose/index.html","hash":"a8f1285c767e9e9426f8fbff4cd9e1e69cd91bc7","modified":1688733164602},{"_id":"public/tags/Cookie/index.html","hash":"a8f1285c767e9e9426f8fbff4cd9e1e69cd91bc7","modified":1688733164602},{"_id":"public/tags/Session/index.html","hash":"a8f1285c767e9e9426f8fbff4cd9e1e69cd91bc7","modified":1688733164602},{"_id":"public/tags/Token/index.html","hash":"a8f1285c767e9e9426f8fbff4cd9e1e69cd91bc7","modified":1688733164602},{"_id":"public/tags/jwt/index.html","hash":"a8f1285c767e9e9426f8fbff4cd9e1e69cd91bc7","modified":1688733164602},{"_id":"public/scss/index.scss","hash":"846907e85f21506e5fcf7784a92c10634b721b47","modified":1688731578835},{"_id":"public/scss/post.scss","hash":"02c77c3705753dc7d89460961c050b91b748c4d8","modified":1688731578835},{"_id":"public/scss/layout.scss","hash":"a083f7975374b1300741402c079588377be97602","modified":1688731578835},{"_id":"public/scss/reset.scss","hash":"e7441d5f0c428294a54dc854a0117087df5abb59","modified":1688731578835},{"_id":"public/css/prism-duotone-light.css","hash":"abfcef8e2d0498e6c92887d45afcb9e26d91f90a","modified":1688731578835},{"_id":"public/css/prism-line-numbers.css","hash":"a1692758d22c6cdf6fd1a8dafc9b4b98e41d3138","modified":1688731578835},{"_id":"public/css/index.css","hash":"f1dcff497e5a75c943fa61fd304661d07023a9cf","modified":1688731578835},{"_id":"public/css/layout.css","hash":"6496d99ea85fb1003c1bbcdd3f3688dcc585eae5","modified":1688731578835},{"_id":"public/css/post.css","hash":"1e5199580d590091f1a6967bda7784e0b2fa364d","modified":1688731578835},{"_id":"public/css/reset.css","hash":"661acb1b2327e3f3e84e8fc0c4c428f092add5a5","modified":1688731578835},{"_id":"public/js/dayjs.min.js","hash":"fbc3c0c699176264398b1eed7dab87c8c5c56126","modified":1688731578835},{"_id":"public/js/index.js","hash":"610b886543488c9299d5781ef1ea62eef7d32c2a","modified":1688731578835},{"_id":"public/js/layout.js","hash":"610b886543488c9299d5781ef1ea62eef7d32c2a","modified":1688731578835}],"Category":[{"name":"文章","_id":"cljsj5zk70004jaf91v06d9uf"},{"name":"docker","parent":"cljsj5zk70004jaf91v06d9uf","_id":"cljsj5zkj000fjaf9cjfe7eni"},{"name":"随笔","parent":"cljsj5zk70004jaf91v06d9uf","_id":"cljsj5zkk000ijaf94mck9zcz"},{"name":"auth","parent":"cljsj5zk70004jaf91v06d9uf","_id":"cljsj5zkl000mjaf94ht201sm"}],"Data":[],"Page":[{"title":"catrgories","date":"2023-07-07T02:15:24.000Z","_content":"","source":"catrgories/index.md","raw":"---\ntitle: catrgories\ndate: 2023-07-07 10:15:24\n---\n","updated":"2023-07-07T02:15:24.268Z","path":"catrgories/index.html","comments":1,"layout":"page","_id":"cljsj5zjy0000jaf90fu7f96j","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"about","date":"2023-07-06T05:50:18.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2023-07-06 13:50:18\n---\n","updated":"2023-07-06T05:50:18.913Z","path":"about/index.html","comments":1,"layout":"page","_id":"cljsj5zk40002jaf98udndrx1","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2023-07-07T02:15:33.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2023-07-07 10:15:33\n---\n","updated":"2023-07-07T02:15:33.176Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cljsj5zk90005jaf9goq0csaa","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"初始化","date":"2023-05-16T12:00:00.000Z","author":"ego","_content":"\n## 前言\n突然不知道第一篇写什么，  \n说你好又显得有点奇怪，  \n脑中只回荡这首歌，  \n就用歌词作为开头吧。  \n\n\n## The Sound of Silence\n\nHello darkness, my old friend  \nI've come to talk with you again  \nBecause a vision softly creeping  \nLeft its seeds while I was sleeping  \nAnd the vision that was planted in my brain  \nStill remains  \n\nWithin the sound of silence  \nIn restless dreams, I walked alone  \nNarrow streets of cobblestone  \n'Neath the halo of a streetlamp  \nI turned my collar to the cold and damp  \nWhen my eyes were stabbed by the flash of a neon light  \nThat split the night    \n\n\nAnd touched the sound of silence  \nAnd in the naked light, I saw  \nTen thousand people, maybe more  \nPeople talking without speaking  \nPeople hearing without listening  \nPeople writing songs that voices never shared  \nNo one dared    \n\nDisturb the sound of silence  \n\"Fools\", said I, \"You do not know  \nSilence like a cancer grows  \nHear my words that I might teach you  \nTake my arms that I might reach you\"  \nBut my words like silent raindrops fell  \nAnd echoed in the wells of silence    \n\nAnd the people bowed and prayed  \nTo the neon god they made  \nAnd the sign flashed out its warning  \nIn the words that it was forming   \nAnd the sign said, \"The words of the prophets are written on the subway walls   \nIn tenement halls\"  \nAnd whispered in the sounds of silence  ","source":"_posts/2023-05-15-hello.md","raw":"---\ntitle: 初始化\ndate: 2023-05-16 20:00:00 +0800\ncategories: [文章, 随笔]\ntags: []\nauthor: ego\n---\n\n## 前言\n突然不知道第一篇写什么，  \n说你好又显得有点奇怪，  \n脑中只回荡这首歌，  \n就用歌词作为开头吧。  \n\n\n## The Sound of Silence\n\nHello darkness, my old friend  \nI've come to talk with you again  \nBecause a vision softly creeping  \nLeft its seeds while I was sleeping  \nAnd the vision that was planted in my brain  \nStill remains  \n\nWithin the sound of silence  \nIn restless dreams, I walked alone  \nNarrow streets of cobblestone  \n'Neath the halo of a streetlamp  \nI turned my collar to the cold and damp  \nWhen my eyes were stabbed by the flash of a neon light  \nThat split the night    \n\n\nAnd touched the sound of silence  \nAnd in the naked light, I saw  \nTen thousand people, maybe more  \nPeople talking without speaking  \nPeople hearing without listening  \nPeople writing songs that voices never shared  \nNo one dared    \n\nDisturb the sound of silence  \n\"Fools\", said I, \"You do not know  \nSilence like a cancer grows  \nHear my words that I might teach you  \nTake my arms that I might reach you\"  \nBut my words like silent raindrops fell  \nAnd echoed in the wells of silence    \n\nAnd the people bowed and prayed  \nTo the neon god they made  \nAnd the sign flashed out its warning  \nIn the words that it was forming   \nAnd the sign said, \"The words of the prophets are written on the subway walls   \nIn tenement halls\"  \nAnd whispered in the sounds of silence  ","slug":"2023-05-15-hello","published":1,"updated":"2023-07-07T04:40:43.708Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljsj5zk10001jaf9amu6h3os","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>突然不知道第一篇写什么，<br>说你好又显得有点奇怪，<br>脑中只回荡这首歌，<br>就用歌词作为开头吧。  </p>\n<h2 id=\"The-Sound-of-Silence\"><a href=\"#The-Sound-of-Silence\" class=\"headerlink\" title=\"The Sound of Silence\"></a>The Sound of Silence</h2><p>Hello darkness, my old friend<br>I’ve come to talk with you again<br>Because a vision softly creeping<br>Left its seeds while I was sleeping<br>And the vision that was planted in my brain<br>Still remains  </p>\n<p>Within the sound of silence<br>In restless dreams, I walked alone<br>Narrow streets of cobblestone<br>‘Neath the halo of a streetlamp<br>I turned my collar to the cold and damp<br>When my eyes were stabbed by the flash of a neon light<br>That split the night    </p>\n<p>And touched the sound of silence<br>And in the naked light, I saw<br>Ten thousand people, maybe more<br>People talking without speaking<br>People hearing without listening<br>People writing songs that voices never shared<br>No one dared    </p>\n<p>Disturb the sound of silence<br>“Fools”, said I, “You do not know<br>Silence like a cancer grows<br>Hear my words that I might teach you<br>Take my arms that I might reach you”<br>But my words like silent raindrops fell<br>And echoed in the wells of silence    </p>\n<p>And the people bowed and prayed<br>To the neon god they made<br>And the sign flashed out its warning<br>In the words that it was forming<br>And the sign said, “The words of the prophets are written on the subway walls<br>In tenement halls”<br>And whispered in the sounds of silence  </p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>突然不知道第一篇写什么，<br>说你好又显得有点奇怪，<br>脑中只回荡这首歌，<br>就用歌词作为开头吧。  </p>\n<h2 id=\"The-Sound-of-Silence\"><a href=\"#The-Sound-of-Silence\" class=\"headerlink\" title=\"The Sound of Silence\"></a>The Sound of Silence</h2><p>Hello darkness, my old friend<br>I’ve come to talk with you again<br>Because a vision softly creeping<br>Left its seeds while I was sleeping<br>And the vision that was planted in my brain<br>Still remains  </p>\n<p>Within the sound of silence<br>In restless dreams, I walked alone<br>Narrow streets of cobblestone<br>‘Neath the halo of a streetlamp<br>I turned my collar to the cold and damp<br>When my eyes were stabbed by the flash of a neon light<br>That split the night    </p>\n<p>And touched the sound of silence<br>And in the naked light, I saw<br>Ten thousand people, maybe more<br>People talking without speaking<br>People hearing without listening<br>People writing songs that voices never shared<br>No one dared    </p>\n<p>Disturb the sound of silence<br>“Fools”, said I, “You do not know<br>Silence like a cancer grows<br>Hear my words that I might teach you<br>Take my arms that I might reach you”<br>But my words like silent raindrops fell<br>And echoed in the wells of silence    </p>\n<p>And the people bowed and prayed<br>To the neon god they made<br>And the sign flashed out its warning<br>In the words that it was forming<br>And the sign said, “The words of the prophets are written on the subway walls<br>In tenement halls”<br>And whispered in the sounds of silence  </p>\n"},{"title":"docker 之基础概念和使用","date":"2023-06-01T12:00:00.000Z","author":"ego","_content":"\n# 主要概念\n- **镜像**：Image，是用于创建 Docker 容器的模板，比如 Ubuntu 系统，类似本地的 一个个 git 仓库源码。\n- **容器**：Container，是镜像运行时的实体，镜像和容器的关系就比如：**类（镜像）和实例（容器）**\n- **仓库**：Repository，仓库可看成一个代码控制中心，用来保存镜像，类似本地的 git 仓库。\n- **Docker Machine**: 是一个简化Docker安装的命令行工具\n- **Dockerfile**: 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明\n\n- **Docker仓库**: 用来保存镜像，可以理解为代码控制中的代码仓库，类似 github。\n [Docker Hub](https://hub.docker.com) 提供了庞大的镜像集合供使用。\n\n\n# 一次完整的操作\n```\n# 查看本地所有镜像\ndocker images\n\n# 拉取最新的 ubuntu 镜像\ndocker pull ubuntu:latest\n\n# 启动一个 ubuntu 的容器\nsudo docker run -it -d -p 7000:7000 ubuntu:latest /bin/bash\n# -p 指定映射端口：外部 8000 ，docker 容器内部 7000\n# -d 后台方式运行\n# -it 表示开启交互模式，并将用户当前的 shell 连接到容器内部，将 shell切换到容器的终端\n# /bin/bash 运行 ubuntu 容器环境内部的此命令\n\n# 将 shell 连接到正在后台运行的容器终端\nsudo docker exec -it <容器ID> /bin/bash\n\n# 退出 ubuntu 容器内部的终端，切换到用户 shell\nexit 或者 Ctrl + D\n\n# 确认正在运行的容器有哪些\ndocker ps\n或者 docker container ls\ndocker ps -a # 查看所有容器，包括已经停止的容器 \n\n# 启动/重启/停止/强制停止/移除 容器\ndocker container start/restart/stop/kill/rm <容器ID>\n```\n\n# 其他操作\n```\n# 查看容器日志\ndocker logs <容器ID>\n\n# 查看容器资源消耗\ndocker stats \n```","source":"_posts/2023-06-01-docker-base.md","raw":"---\ntitle: docker 之基础概念和使用\ndate: 2023-06-01 20:00:00 +0800\ncategories: [文章, docker]\ntags: [docker]\nauthor: ego\n---\n\n# 主要概念\n- **镜像**：Image，是用于创建 Docker 容器的模板，比如 Ubuntu 系统，类似本地的 一个个 git 仓库源码。\n- **容器**：Container，是镜像运行时的实体，镜像和容器的关系就比如：**类（镜像）和实例（容器）**\n- **仓库**：Repository，仓库可看成一个代码控制中心，用来保存镜像，类似本地的 git 仓库。\n- **Docker Machine**: 是一个简化Docker安装的命令行工具\n- **Dockerfile**: 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明\n\n- **Docker仓库**: 用来保存镜像，可以理解为代码控制中的代码仓库，类似 github。\n [Docker Hub](https://hub.docker.com) 提供了庞大的镜像集合供使用。\n\n\n# 一次完整的操作\n```\n# 查看本地所有镜像\ndocker images\n\n# 拉取最新的 ubuntu 镜像\ndocker pull ubuntu:latest\n\n# 启动一个 ubuntu 的容器\nsudo docker run -it -d -p 7000:7000 ubuntu:latest /bin/bash\n# -p 指定映射端口：外部 8000 ，docker 容器内部 7000\n# -d 后台方式运行\n# -it 表示开启交互模式，并将用户当前的 shell 连接到容器内部，将 shell切换到容器的终端\n# /bin/bash 运行 ubuntu 容器环境内部的此命令\n\n# 将 shell 连接到正在后台运行的容器终端\nsudo docker exec -it <容器ID> /bin/bash\n\n# 退出 ubuntu 容器内部的终端，切换到用户 shell\nexit 或者 Ctrl + D\n\n# 确认正在运行的容器有哪些\ndocker ps\n或者 docker container ls\ndocker ps -a # 查看所有容器，包括已经停止的容器 \n\n# 启动/重启/停止/强制停止/移除 容器\ndocker container start/restart/stop/kill/rm <容器ID>\n```\n\n# 其他操作\n```\n# 查看容器日志\ndocker logs <容器ID>\n\n# 查看容器资源消耗\ndocker stats \n```","slug":"2023-06-01-docker-base","published":1,"updated":"2023-07-07T04:38:38.120Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljsj5zk50003jaf9g6jr295i","content":"<h1 id=\"主要概念\"><a href=\"#主要概念\" class=\"headerlink\" title=\"主要概念\"></a>主要概念</h1><ul>\n<li><p><strong>镜像</strong>：Image，是用于创建 Docker 容器的模板，比如 Ubuntu 系统，类似本地的 一个个 git 仓库源码。</p>\n</li>\n<li><p><strong>容器</strong>：Container，是镜像运行时的实体，镜像和容器的关系就比如：<strong>类（镜像）和实例（容器）</strong></p>\n</li>\n<li><p><strong>仓库</strong>：Repository，仓库可看成一个代码控制中心，用来保存镜像，类似本地的 git 仓库。</p>\n</li>\n<li><p><strong>Docker Machine</strong>: 是一个简化Docker安装的命令行工具</p>\n</li>\n<li><p><strong>Dockerfile</strong>: 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明</p>\n</li>\n<li><p><strong>Docker仓库</strong>: 用来保存镜像，可以理解为代码控制中的代码仓库，类似 github。<br> <a href=\"https://hub.docker.com/\">Docker Hub</a> 提供了庞大的镜像集合供使用。</p>\n</li>\n</ul>\n<h1 id=\"一次完整的操作\"><a href=\"#一次完整的操作\" class=\"headerlink\" title=\"一次完整的操作\"></a>一次完整的操作</h1><pre><code># 查看本地所有镜像\ndocker images\n\n# 拉取最新的 ubuntu 镜像\ndocker pull ubuntu:latest\n\n# 启动一个 ubuntu 的容器\nsudo docker run -it -d -p 7000:7000 ubuntu:latest /bin/bash\n# -p 指定映射端口：外部 8000 ，docker 容器内部 7000\n# -d 后台方式运行\n# -it 表示开启交互模式，并将用户当前的 shell 连接到容器内部，将 shell切换到容器的终端\n# /bin/bash 运行 ubuntu 容器环境内部的此命令\n\n# 将 shell 连接到正在后台运行的容器终端\nsudo docker exec -it &lt;容器ID&gt; /bin/bash\n\n# 退出 ubuntu 容器内部的终端，切换到用户 shell\nexit 或者 Ctrl + D\n\n# 确认正在运行的容器有哪些\ndocker ps\n或者 docker container ls\ndocker ps -a # 查看所有容器，包括已经停止的容器 \n\n# 启动/重启/停止/强制停止/移除 容器\ndocker container start/restart/stop/kill/rm &lt;容器ID&gt;\n</code></pre>\n<h1 id=\"其他操作\"><a href=\"#其他操作\" class=\"headerlink\" title=\"其他操作\"></a>其他操作</h1><pre><code># 查看容器日志\ndocker logs &lt;容器ID&gt;\n\n# 查看容器资源消耗\ndocker stats \n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"主要概念\"><a href=\"#主要概念\" class=\"headerlink\" title=\"主要概念\"></a>主要概念</h1><ul>\n<li><p><strong>镜像</strong>：Image，是用于创建 Docker 容器的模板，比如 Ubuntu 系统，类似本地的 一个个 git 仓库源码。</p>\n</li>\n<li><p><strong>容器</strong>：Container，是镜像运行时的实体，镜像和容器的关系就比如：<strong>类（镜像）和实例（容器）</strong></p>\n</li>\n<li><p><strong>仓库</strong>：Repository，仓库可看成一个代码控制中心，用来保存镜像，类似本地的 git 仓库。</p>\n</li>\n<li><p><strong>Docker Machine</strong>: 是一个简化Docker安装的命令行工具</p>\n</li>\n<li><p><strong>Dockerfile</strong>: 是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明</p>\n</li>\n<li><p><strong>Docker仓库</strong>: 用来保存镜像，可以理解为代码控制中的代码仓库，类似 github。<br> <a href=\"https://hub.docker.com/\">Docker Hub</a> 提供了庞大的镜像集合供使用。</p>\n</li>\n</ul>\n<h1 id=\"一次完整的操作\"><a href=\"#一次完整的操作\" class=\"headerlink\" title=\"一次完整的操作\"></a>一次完整的操作</h1><pre><code># 查看本地所有镜像\ndocker images\n\n# 拉取最新的 ubuntu 镜像\ndocker pull ubuntu:latest\n\n# 启动一个 ubuntu 的容器\nsudo docker run -it -d -p 7000:7000 ubuntu:latest /bin/bash\n# -p 指定映射端口：外部 8000 ，docker 容器内部 7000\n# -d 后台方式运行\n# -it 表示开启交互模式，并将用户当前的 shell 连接到容器内部，将 shell切换到容器的终端\n# /bin/bash 运行 ubuntu 容器环境内部的此命令\n\n# 将 shell 连接到正在后台运行的容器终端\nsudo docker exec -it &lt;容器ID&gt; /bin/bash\n\n# 退出 ubuntu 容器内部的终端，切换到用户 shell\nexit 或者 Ctrl + D\n\n# 确认正在运行的容器有哪些\ndocker ps\n或者 docker container ls\ndocker ps -a # 查看所有容器，包括已经停止的容器 \n\n# 启动/重启/停止/强制停止/移除 容器\ndocker container start/restart/stop/kill/rm &lt;容器ID&gt;\n</code></pre>\n<h1 id=\"其他操作\"><a href=\"#其他操作\" class=\"headerlink\" title=\"其他操作\"></a>其他操作</h1><pre><code># 查看容器日志\ndocker logs &lt;容器ID&gt;\n\n# 查看容器资源消耗\ndocker stats \n</code></pre>\n"},{"title":"docker 之部署 clickhouse-server 及数据存储","date":"2023-06-04T12:00:00.000Z","author":"ego","_content":"\n## 1. 在本机创建同步数据目录\n数据存储在 `/data/clickhouse` 目录下  \n```shell\n# 创建基本目录结构\nmkdir -p /data/clickhouse/data /data/clickhouse/config /data/clickhouse/log  \n\n# 查看创建的目录\ntree /data \n# data\n# └── clickhouse\n#     ├── config # 存基本配置文件\n#     ├── data # 映射数据文件\n#     └── log # 映射日志\n```\n\n## 2. 拷贝 clickhouse 配置文件\n### 2.1 启服务\n```shell\ndocker run -d \\\n--name clickhouse-server \\  # --name 命名容器\n--ulimit nofile=262144:262144 \\\n-p 8123:8123 \\\n-p 9000:9000 \\\n-p 9009:9009 \\\nyandex/clickhouse-server:latest\n```\n\n### 2.2 将容器内部的配置文件拷贝到宿主机  \n主要是 `config.xml` 和 `users.xml` 拷贝到宿主机目录 `/data/clickhouse/config` 下 \n```shell\n# config.xml\ndocker cp clickhouse-server:/etc/clickhouse-server/config.xml /data/clickhouse/config/config.xml\n\n# users.xml\ndocker cp clickhouse-server:/etc/clickhouse-server/users.xml /data/clickhouse/config/users.xml\n```\n\n## 3. 修改 clickhouse 密码\n### 3.1 生成 sha256 密码\n```shell\nPASSWORD=$(base64 < /dev/urandom | head -c14); echo \"123456\"; echo -n \"123456\" | sha256sum | tr -d '-'\n# 输出如下\n# 123456 # 明文密码\n# 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92 # 加密后密码\n```\n\n### 3.2 修改 users.xml 配置文件里面的密码\n```shell \nvim /data/clickhouse/config/users.xml\n# 替换 <password></password>  为<password_sha256_hex>8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92</password_sha256_hex>  # 中间是密码 123456 加密的密文\n```\n\n### 3.3 增加一个 root 用户\n找到 users 里面的 default 用户，在下面增加 root 用户的配置\n```xml\n<users>\n    <default>xxx</default>  <!--default 用户的配置-->\n    <root>xxx</root> <!--新增的 root 用户配置-->\n</users>\n```\n\nroot 用户配置\n```xml\n<root>   <!--用户名：root-->\n<!--     <password>root</password>  明文密码，官网不推荐使用明文 -->\n    <password_sha256_hex>4813494d137e1631bba301d5acab6e7bb7aa74ce1185d456565ef51d7      37677b2</password_sha256_hex> <!--加密密码：sha256-->\n    <networks incl=\"networks\" replace=\"replace\">  <!--网络设置，限制可登陆的客户端地址-->\n      <ip>::/0</ip>  <!--为所有客户端打开权限-->\n    </networks>\n    <profile>default</profile>\n    <quota>default</quota>\n</root>\n```\n\n## 4 部署 clickhouse-server\n### 4.1 先移除刚才创建的容器\n```shell\ndocker rm -f 容器ID\n```\n\n### 4.2 部署 clickhouse-server 并挂载数据目录\n```shell \ndocker run -d \\\n--name clickhouse-server \\\n--ulimit nofile=262144:262144 \\\n-p 8123:8123 \\\n-p 9000:9000 \\\n-p 9009:9009 \\\n# -v 挂载目录，同步宿主目录到容器目录\n-v /data/clickhouse/data:/var/lib/clickhouse:rw \\  \n# :rw 执行读写两个权限 r:read,w:write linux 文件权限\n-v /data/clickhouse/log:/var/log/clickhouse-server:rw \\  \n-v /data/clickhouse/config/config.xml:/etc/clickhouse-server/config.xml \\\n-v /data/clickhouse/config/users.xml:/etc/clickhouse-server/users.xml \\\nyandex/clickhouse-server:latest\n```\n现在就可以用 root 123456 登录现在的容器 clickhouse-server 了。  \n即使容器被销毁，下次重新用上面的部署命令启一个容器也会同步最新数据。  \n\n### 4.3 最终 `/data` 目录长这样 \n```text\n/data\n└── clickhouse\n    ├── config\n    │   ├── config.xml\n    │   └── users.xml\n    ├── data\n    │   ├── access [error opening dir]\n    │   ├── data [error opening dir]\n    │   ├── dictionaries_lib [error opening dir]\n    │   ├── flags [error opening dir]\n    │   ├── ...\n    └── log\n        ├── clickhouse-server.err.log\n        └── clickhouse-server.log\n```\n\n\n## 参考\n[clickhouse 新建用户和密码](https://www.cnblogs.com/yoyo1216/p/12835941.html)","source":"_posts/2023-06-05-docker-clickhouse.md","raw":"---\ntitle: docker 之部署 clickhouse-server 及数据存储\ndate: 2023-06-04 20:00:00 +0800\ncategories: [文章, docker]\ntags: [docker,clickhouse]\nauthor: ego\n---\n\n## 1. 在本机创建同步数据目录\n数据存储在 `/data/clickhouse` 目录下  \n```shell\n# 创建基本目录结构\nmkdir -p /data/clickhouse/data /data/clickhouse/config /data/clickhouse/log  \n\n# 查看创建的目录\ntree /data \n# data\n# └── clickhouse\n#     ├── config # 存基本配置文件\n#     ├── data # 映射数据文件\n#     └── log # 映射日志\n```\n\n## 2. 拷贝 clickhouse 配置文件\n### 2.1 启服务\n```shell\ndocker run -d \\\n--name clickhouse-server \\  # --name 命名容器\n--ulimit nofile=262144:262144 \\\n-p 8123:8123 \\\n-p 9000:9000 \\\n-p 9009:9009 \\\nyandex/clickhouse-server:latest\n```\n\n### 2.2 将容器内部的配置文件拷贝到宿主机  \n主要是 `config.xml` 和 `users.xml` 拷贝到宿主机目录 `/data/clickhouse/config` 下 \n```shell\n# config.xml\ndocker cp clickhouse-server:/etc/clickhouse-server/config.xml /data/clickhouse/config/config.xml\n\n# users.xml\ndocker cp clickhouse-server:/etc/clickhouse-server/users.xml /data/clickhouse/config/users.xml\n```\n\n## 3. 修改 clickhouse 密码\n### 3.1 生成 sha256 密码\n```shell\nPASSWORD=$(base64 < /dev/urandom | head -c14); echo \"123456\"; echo -n \"123456\" | sha256sum | tr -d '-'\n# 输出如下\n# 123456 # 明文密码\n# 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92 # 加密后密码\n```\n\n### 3.2 修改 users.xml 配置文件里面的密码\n```shell \nvim /data/clickhouse/config/users.xml\n# 替换 <password></password>  为<password_sha256_hex>8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92</password_sha256_hex>  # 中间是密码 123456 加密的密文\n```\n\n### 3.3 增加一个 root 用户\n找到 users 里面的 default 用户，在下面增加 root 用户的配置\n```xml\n<users>\n    <default>xxx</default>  <!--default 用户的配置-->\n    <root>xxx</root> <!--新增的 root 用户配置-->\n</users>\n```\n\nroot 用户配置\n```xml\n<root>   <!--用户名：root-->\n<!--     <password>root</password>  明文密码，官网不推荐使用明文 -->\n    <password_sha256_hex>4813494d137e1631bba301d5acab6e7bb7aa74ce1185d456565ef51d7      37677b2</password_sha256_hex> <!--加密密码：sha256-->\n    <networks incl=\"networks\" replace=\"replace\">  <!--网络设置，限制可登陆的客户端地址-->\n      <ip>::/0</ip>  <!--为所有客户端打开权限-->\n    </networks>\n    <profile>default</profile>\n    <quota>default</quota>\n</root>\n```\n\n## 4 部署 clickhouse-server\n### 4.1 先移除刚才创建的容器\n```shell\ndocker rm -f 容器ID\n```\n\n### 4.2 部署 clickhouse-server 并挂载数据目录\n```shell \ndocker run -d \\\n--name clickhouse-server \\\n--ulimit nofile=262144:262144 \\\n-p 8123:8123 \\\n-p 9000:9000 \\\n-p 9009:9009 \\\n# -v 挂载目录，同步宿主目录到容器目录\n-v /data/clickhouse/data:/var/lib/clickhouse:rw \\  \n# :rw 执行读写两个权限 r:read,w:write linux 文件权限\n-v /data/clickhouse/log:/var/log/clickhouse-server:rw \\  \n-v /data/clickhouse/config/config.xml:/etc/clickhouse-server/config.xml \\\n-v /data/clickhouse/config/users.xml:/etc/clickhouse-server/users.xml \\\nyandex/clickhouse-server:latest\n```\n现在就可以用 root 123456 登录现在的容器 clickhouse-server 了。  \n即使容器被销毁，下次重新用上面的部署命令启一个容器也会同步最新数据。  \n\n### 4.3 最终 `/data` 目录长这样 \n```text\n/data\n└── clickhouse\n    ├── config\n    │   ├── config.xml\n    │   └── users.xml\n    ├── data\n    │   ├── access [error opening dir]\n    │   ├── data [error opening dir]\n    │   ├── dictionaries_lib [error opening dir]\n    │   ├── flags [error opening dir]\n    │   ├── ...\n    └── log\n        ├── clickhouse-server.err.log\n        └── clickhouse-server.log\n```\n\n\n## 参考\n[clickhouse 新建用户和密码](https://www.cnblogs.com/yoyo1216/p/12835941.html)","slug":"2023-06-05-docker-clickhouse","published":1,"updated":"2023-07-07T04:38:38.120Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljsj5zka0006jaf97vnyf429","content":"<h2 id=\"1-在本机创建同步数据目录\"><a href=\"#1-在本机创建同步数据目录\" class=\"headerlink\" title=\"1. 在本机创建同步数据目录\"></a>1. 在本机创建同步数据目录</h2><p>数据存储在 <code>/data/clickhouse</code> 目录下  </p>\n<pre class=\"line-numbers language-shell\"><code class=\"language-shell\"># 创建基本目录结构\nmkdir -p /data/clickhouse/data /data/clickhouse/config /data/clickhouse/log  \n\n# 查看创建的目录\ntree /data \n# data\n# └── clickhouse\n#     ├── config # 存基本配置文件\n#     ├── data # 映射数据文件\n#     └── log # 映射日志\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"2-拷贝-clickhouse-配置文件\"><a href=\"#2-拷贝-clickhouse-配置文件\" class=\"headerlink\" title=\"2. 拷贝 clickhouse 配置文件\"></a>2. 拷贝 clickhouse 配置文件</h2><h3 id=\"2-1-启服务\"><a href=\"#2-1-启服务\" class=\"headerlink\" title=\"2.1 启服务\"></a>2.1 启服务</h3><pre class=\"line-numbers language-shell\"><code class=\"language-shell\">docker run -d \\\n--name clickhouse-server \\  # --name 命名容器\n--ulimit nofile=262144:262144 \\\n-p 8123:8123 \\\n-p 9000:9000 \\\n-p 9009:9009 \\\nyandex/clickhouse-server:latest\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"2-2-将容器内部的配置文件拷贝到宿主机\"><a href=\"#2-2-将容器内部的配置文件拷贝到宿主机\" class=\"headerlink\" title=\"2.2 将容器内部的配置文件拷贝到宿主机\"></a>2.2 将容器内部的配置文件拷贝到宿主机</h3><p>主要是 <code>config.xml</code> 和 <code>users.xml</code> 拷贝到宿主机目录 <code>/data/clickhouse/config</code> 下 </p>\n<pre class=\"line-numbers language-shell\"><code class=\"language-shell\"># config.xml\ndocker cp clickhouse-server:/etc/clickhouse-server/config.xml /data/clickhouse/config/config.xml\n\n# users.xml\ndocker cp clickhouse-server:/etc/clickhouse-server/users.xml /data/clickhouse/config/users.xml\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"3-修改-clickhouse-密码\"><a href=\"#3-修改-clickhouse-密码\" class=\"headerlink\" title=\"3. 修改 clickhouse 密码\"></a>3. 修改 clickhouse 密码</h2><h3 id=\"3-1-生成-sha256-密码\"><a href=\"#3-1-生成-sha256-密码\" class=\"headerlink\" title=\"3.1 生成 sha256 密码\"></a>3.1 生成 sha256 密码</h3><pre class=\"line-numbers language-shell\"><code class=\"language-shell\">PASSWORD=$(base64 < /dev/urandom | head -c14); echo \"123456\"; echo -n \"123456\" | sha256sum | tr -d '-'\n# 输出如下\n# 123456 # 明文密码\n# 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92 # 加密后密码\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<h3 id=\"3-2-修改-users-xml-配置文件里面的密码\"><a href=\"#3-2-修改-users-xml-配置文件里面的密码\" class=\"headerlink\" title=\"3.2 修改 users.xml 配置文件里面的密码\"></a>3.2 修改 users.xml 配置文件里面的密码</h3><pre class=\"line-numbers language-shell\"><code class=\"language-shell\">vim /data/clickhouse/config/users.xml\n# 替换 <password></password>  为<password_sha256_hex>8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92</password_sha256_hex>  # 中间是密码 123456 加密的密文\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n<h3 id=\"3-3-增加一个-root-用户\"><a href=\"#3-3-增加一个-root-用户\" class=\"headerlink\" title=\"3.3 增加一个 root 用户\"></a>3.3 增加一个 root 用户</h3><p>找到 users 里面的 default 用户，在下面增加 root 用户的配置</p>\n<pre class=\"line-numbers language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>users</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>default</span><span class=\"token punctuation\">></span></span>xxx<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>default</span><span class=\"token punctuation\">></span></span>  <span class=\"token comment\" spellcheck=\"true\">&lt;!--default 用户的配置--></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>root</span><span class=\"token punctuation\">></span></span>xxx<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>root</span><span class=\"token punctuation\">></span></span> <span class=\"token comment\" spellcheck=\"true\">&lt;!--新增的 root 用户配置--></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>users</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n<p>root 用户配置</p>\n<pre class=\"line-numbers language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>root</span><span class=\"token punctuation\">></span></span>   <span class=\"token comment\" spellcheck=\"true\">&lt;!--用户名：root--></span>\n<span class=\"token comment\" spellcheck=\"true\">&lt;!--     &lt;password>root&lt;/password>  明文密码，官网不推荐使用明文 --></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>password_sha256_hex</span><span class=\"token punctuation\">></span></span>4813494d137e1631bba301d5acab6e7bb7aa74ce1185d456565ef51d7      37677b2<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>password_sha256_hex</span><span class=\"token punctuation\">></span></span> <span class=\"token comment\" spellcheck=\"true\">&lt;!--加密密码：sha256--></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>networks</span> <span class=\"token attr-name\">incl</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>networks<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">replace</span><span class=\"token attr-value\"><span class=\"token punctuation\">=</span><span class=\"token punctuation\">\"</span>replace<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>  <span class=\"token comment\" spellcheck=\"true\">&lt;!--网络设置，限制可登陆的客户端地址--></span>\n      <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ip</span><span class=\"token punctuation\">></span></span>::/0<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>ip</span><span class=\"token punctuation\">></span></span>  <span class=\"token comment\" spellcheck=\"true\">&lt;!--为所有客户端打开权限--></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>networks</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>profile</span><span class=\"token punctuation\">></span></span>default<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>profile</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>quota</span><span class=\"token punctuation\">></span></span>default<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>quota</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>root</span><span class=\"token punctuation\">></span></span>\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"4-部署-clickhouse-server\"><a href=\"#4-部署-clickhouse-server\" class=\"headerlink\" title=\"4 部署 clickhouse-server\"></a>4 部署 clickhouse-server</h2><h3 id=\"4-1-先移除刚才创建的容器\"><a href=\"#4-1-先移除刚才创建的容器\" class=\"headerlink\" title=\"4.1 先移除刚才创建的容器\"></a>4.1 先移除刚才创建的容器</h3><pre class=\"line-numbers language-shell\"><code class=\"language-shell\">docker rm -f 容器ID\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<h3 id=\"4-2-部署-clickhouse-server-并挂载数据目录\"><a href=\"#4-2-部署-clickhouse-server-并挂载数据目录\" class=\"headerlink\" title=\"4.2 部署 clickhouse-server 并挂载数据目录\"></a>4.2 部署 clickhouse-server 并挂载数据目录</h3><pre class=\"line-numbers language-shell\"><code class=\"language-shell\">docker run -d \\\n--name clickhouse-server \\\n--ulimit nofile=262144:262144 \\\n-p 8123:8123 \\\n-p 9000:9000 \\\n-p 9009:9009 \\\n# -v 挂载目录，同步宿主目录到容器目录\n-v /data/clickhouse/data:/var/lib/clickhouse:rw \\  \n# :rw 执行读写两个权限 r:read,w:write linux 文件权限\n-v /data/clickhouse/log:/var/log/clickhouse-server:rw \\  \n-v /data/clickhouse/config/config.xml:/etc/clickhouse-server/config.xml \\\n-v /data/clickhouse/config/users.xml:/etc/clickhouse-server/users.xml \\\nyandex/clickhouse-server:latest\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>现在就可以用 root 123456 登录现在的容器 clickhouse-server 了。<br>即使容器被销毁，下次重新用上面的部署命令启一个容器也会同步最新数据。  </p>\n<h3 id=\"4-3-最终-data-目录长这样\"><a href=\"#4-3-最终-data-目录长这样\" class=\"headerlink\" title=\"4.3 最终 /data 目录长这样\"></a>4.3 最终 <code>/data</code> 目录长这样</h3><pre class=\"line-numbers language-text\"><code class=\"language-text\">/data\n└── clickhouse\n    ├── config\n    │   ├── config.xml\n    │   └── users.xml\n    ├── data\n    │   ├── access [error opening dir]\n    │   ├── data [error opening dir]\n    │   ├── dictionaries_lib [error opening dir]\n    │   ├── flags [error opening dir]\n    │   ├── ...\n    └── log\n        ├── clickhouse-server.err.log\n        └── clickhouse-server.log\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.cnblogs.com/yoyo1216/p/12835941.html\">clickhouse 新建用户和密码</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-在本机创建同步数据目录\"><a href=\"#1-在本机创建同步数据目录\" class=\"headerlink\" title=\"1. 在本机创建同步数据目录\"></a>1. 在本机创建同步数据目录</h2><p>数据存储在 <code>/data/clickhouse</code> 目录下  </p>\n<pre><code class=\"shell\"># 创建基本目录结构\nmkdir -p /data/clickhouse/data /data/clickhouse/config /data/clickhouse/log  \n\n# 查看创建的目录\ntree /data \n# data\n# └── clickhouse\n#     ├── config # 存基本配置文件\n#     ├── data # 映射数据文件\n#     └── log # 映射日志\n</code></pre>\n<h2 id=\"2-拷贝-clickhouse-配置文件\"><a href=\"#2-拷贝-clickhouse-配置文件\" class=\"headerlink\" title=\"2. 拷贝 clickhouse 配置文件\"></a>2. 拷贝 clickhouse 配置文件</h2><h3 id=\"2-1-启服务\"><a href=\"#2-1-启服务\" class=\"headerlink\" title=\"2.1 启服务\"></a>2.1 启服务</h3><pre><code class=\"shell\">docker run -d \\\n--name clickhouse-server \\  # --name 命名容器\n--ulimit nofile=262144:262144 \\\n-p 8123:8123 \\\n-p 9000:9000 \\\n-p 9009:9009 \\\nyandex/clickhouse-server:latest\n</code></pre>\n<h3 id=\"2-2-将容器内部的配置文件拷贝到宿主机\"><a href=\"#2-2-将容器内部的配置文件拷贝到宿主机\" class=\"headerlink\" title=\"2.2 将容器内部的配置文件拷贝到宿主机\"></a>2.2 将容器内部的配置文件拷贝到宿主机</h3><p>主要是 <code>config.xml</code> 和 <code>users.xml</code> 拷贝到宿主机目录 <code>/data/clickhouse/config</code> 下 </p>\n<pre><code class=\"shell\"># config.xml\ndocker cp clickhouse-server:/etc/clickhouse-server/config.xml /data/clickhouse/config/config.xml\n\n# users.xml\ndocker cp clickhouse-server:/etc/clickhouse-server/users.xml /data/clickhouse/config/users.xml\n</code></pre>\n<h2 id=\"3-修改-clickhouse-密码\"><a href=\"#3-修改-clickhouse-密码\" class=\"headerlink\" title=\"3. 修改 clickhouse 密码\"></a>3. 修改 clickhouse 密码</h2><h3 id=\"3-1-生成-sha256-密码\"><a href=\"#3-1-生成-sha256-密码\" class=\"headerlink\" title=\"3.1 生成 sha256 密码\"></a>3.1 生成 sha256 密码</h3><pre><code class=\"shell\">PASSWORD=$(base64 &lt; /dev/urandom | head -c14); echo &quot;123456&quot;; echo -n &quot;123456&quot; | sha256sum | tr -d &#39;-&#39;\n# 输出如下\n# 123456 # 明文密码\n# 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92 # 加密后密码\n</code></pre>\n<h3 id=\"3-2-修改-users-xml-配置文件里面的密码\"><a href=\"#3-2-修改-users-xml-配置文件里面的密码\" class=\"headerlink\" title=\"3.2 修改 users.xml 配置文件里面的密码\"></a>3.2 修改 users.xml 配置文件里面的密码</h3><pre><code class=\"shell\">vim /data/clickhouse/config/users.xml\n# 替换 &lt;password&gt;&lt;/password&gt;  为&lt;password_sha256_hex&gt;8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92&lt;/password_sha256_hex&gt;  # 中间是密码 123456 加密的密文\n</code></pre>\n<h3 id=\"3-3-增加一个-root-用户\"><a href=\"#3-3-增加一个-root-用户\" class=\"headerlink\" title=\"3.3 增加一个 root 用户\"></a>3.3 增加一个 root 用户</h3><p>找到 users 里面的 default 用户，在下面增加 root 用户的配置</p>\n<pre><code class=\"xml\">&lt;users&gt;\n    &lt;default&gt;xxx&lt;/default&gt;  &lt;!--default 用户的配置--&gt;\n    &lt;root&gt;xxx&lt;/root&gt; &lt;!--新增的 root 用户配置--&gt;\n&lt;/users&gt;\n</code></pre>\n<p>root 用户配置</p>\n<pre><code class=\"xml\">&lt;root&gt;   &lt;!--用户名：root--&gt;\n&lt;!--     &lt;password&gt;root&lt;/password&gt;  明文密码，官网不推荐使用明文 --&gt;\n    &lt;password_sha256_hex&gt;4813494d137e1631bba301d5acab6e7bb7aa74ce1185d456565ef51d7      37677b2&lt;/password_sha256_hex&gt; &lt;!--加密密码：sha256--&gt;\n    &lt;networks incl=&quot;networks&quot; replace=&quot;replace&quot;&gt;  &lt;!--网络设置，限制可登陆的客户端地址--&gt;\n      &lt;ip&gt;::/0&lt;/ip&gt;  &lt;!--为所有客户端打开权限--&gt;\n    &lt;/networks&gt;\n    &lt;profile&gt;default&lt;/profile&gt;\n    &lt;quota&gt;default&lt;/quota&gt;\n&lt;/root&gt;\n</code></pre>\n<h2 id=\"4-部署-clickhouse-server\"><a href=\"#4-部署-clickhouse-server\" class=\"headerlink\" title=\"4 部署 clickhouse-server\"></a>4 部署 clickhouse-server</h2><h3 id=\"4-1-先移除刚才创建的容器\"><a href=\"#4-1-先移除刚才创建的容器\" class=\"headerlink\" title=\"4.1 先移除刚才创建的容器\"></a>4.1 先移除刚才创建的容器</h3><pre><code class=\"shell\">docker rm -f 容器ID\n</code></pre>\n<h3 id=\"4-2-部署-clickhouse-server-并挂载数据目录\"><a href=\"#4-2-部署-clickhouse-server-并挂载数据目录\" class=\"headerlink\" title=\"4.2 部署 clickhouse-server 并挂载数据目录\"></a>4.2 部署 clickhouse-server 并挂载数据目录</h3><pre><code class=\"shell\">docker run -d \\\n--name clickhouse-server \\\n--ulimit nofile=262144:262144 \\\n-p 8123:8123 \\\n-p 9000:9000 \\\n-p 9009:9009 \\\n# -v 挂载目录，同步宿主目录到容器目录\n-v /data/clickhouse/data:/var/lib/clickhouse:rw \\  \n# :rw 执行读写两个权限 r:read,w:write linux 文件权限\n-v /data/clickhouse/log:/var/log/clickhouse-server:rw \\  \n-v /data/clickhouse/config/config.xml:/etc/clickhouse-server/config.xml \\\n-v /data/clickhouse/config/users.xml:/etc/clickhouse-server/users.xml \\\nyandex/clickhouse-server:latest\n</code></pre>\n<p>现在就可以用 root 123456 登录现在的容器 clickhouse-server 了。<br>即使容器被销毁，下次重新用上面的部署命令启一个容器也会同步最新数据。  </p>\n<h3 id=\"4-3-最终-data-目录长这样\"><a href=\"#4-3-最终-data-目录长这样\" class=\"headerlink\" title=\"4.3 最终 /data 目录长这样\"></a>4.3 最终 <code>/data</code> 目录长这样</h3><pre><code class=\"text\">/data\n└── clickhouse\n    ├── config\n    │   ├── config.xml\n    │   └── users.xml\n    ├── data\n    │   ├── access [error opening dir]\n    │   ├── data [error opening dir]\n    │   ├── dictionaries_lib [error opening dir]\n    │   ├── flags [error opening dir]\n    │   ├── ...\n    └── log\n        ├── clickhouse-server.err.log\n        └── clickhouse-server.log\n</code></pre>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.cnblogs.com/yoyo1216/p/12835941.html\">clickhouse 新建用户和密码</a></p>\n"},{"title":"docker 之使用 compose 文件启动容器 clickhouse-server","date":"2023-06-05T12:00:00.000Z","author":"ego","_content":"\n## docker-compose 安装\n\n```shell\n# linux 安装 docker-compose\ncurl -L https://get.daocloud.io/docker/compose/releases/download/v2.4.1/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose\n\n# 修改执行权限\nsudo chmod +x /usr/local/bin/docker-compose\n\n# 创建软连接\nsudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose\n```\n\n## clickhouse 对应的 docker-compose.yaml\n- 指定配置文件起服务：  \n`docker-compose -f ./xxx.yaml up -d`   \n- 不指定文件名称，会在当前文件夹下找 `docker-compose.yaml` 文件，进行编译   \n`docker-compose up -d`  \n\n```yaml\n# ClickHouse Document: https://clickhouse.com/docs/en/\n# ClickHouse Docker Hub: https://hub.docker.com/r/yandex/clickhouse-server\nservices:\n  clickhouse: # 服务名称，可以多个\n    image: yandex/clickhouse-server:latest # 使用的镜像名称，可以是本地地址\n    container_name: clickhouse-server # 容器名称\n    restart: always\n    ulimits:\n      nofile:\n        soft: 262144\n        hard: 262144\n    ports: # 端口映射\n      - \"8123:8123\"\n      - \"9000:9000\"\n      - \"9009:9009\"\n    volumes: # 数据映射\n      - /data/clickhouse/data:/var/lib/clickhouse:rw \n      - /data/clickhouse/log:/var/log/clickhouse-server:rw\n      - /data/clickhouse/config/config.xml:/etc/clickhouse-server/config.xml\n      - /data/clickhouse/config/users.xml:/etc/clickhouse-server/users.xml\n\n```","source":"_posts/2023-06-05-docker-compose-clickhouse.md","raw":"---\ntitle: docker 之使用 compose 文件启动容器 clickhouse-server\ndate: 2023-06-05 20:00:00 +0800\ncategories: [文章, docker]\ntags: [docker,docker-compose,clickhouse]\nauthor: ego\n---\n\n## docker-compose 安装\n\n```shell\n# linux 安装 docker-compose\ncurl -L https://get.daocloud.io/docker/compose/releases/download/v2.4.1/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose\n\n# 修改执行权限\nsudo chmod +x /usr/local/bin/docker-compose\n\n# 创建软连接\nsudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose\n```\n\n## clickhouse 对应的 docker-compose.yaml\n- 指定配置文件起服务：  \n`docker-compose -f ./xxx.yaml up -d`   \n- 不指定文件名称，会在当前文件夹下找 `docker-compose.yaml` 文件，进行编译   \n`docker-compose up -d`  \n\n```yaml\n# ClickHouse Document: https://clickhouse.com/docs/en/\n# ClickHouse Docker Hub: https://hub.docker.com/r/yandex/clickhouse-server\nservices:\n  clickhouse: # 服务名称，可以多个\n    image: yandex/clickhouse-server:latest # 使用的镜像名称，可以是本地地址\n    container_name: clickhouse-server # 容器名称\n    restart: always\n    ulimits:\n      nofile:\n        soft: 262144\n        hard: 262144\n    ports: # 端口映射\n      - \"8123:8123\"\n      - \"9000:9000\"\n      - \"9009:9009\"\n    volumes: # 数据映射\n      - /data/clickhouse/data:/var/lib/clickhouse:rw \n      - /data/clickhouse/log:/var/log/clickhouse-server:rw\n      - /data/clickhouse/config/config.xml:/etc/clickhouse-server/config.xml\n      - /data/clickhouse/config/users.xml:/etc/clickhouse-server/users.xml\n\n```","slug":"2023-06-05-docker-compose-clickhouse","published":1,"updated":"2023-07-07T04:38:38.124Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cljsj5zkd0008jaf9bzk76dx4","content":"<h2 id=\"docker-compose-安装\"><a href=\"#docker-compose-安装\" class=\"headerlink\" title=\"docker-compose 安装\"></a>docker-compose 安装</h2><pre class=\"line-numbers language-shell\"><code class=\"language-shell\"># linux 安装 docker-compose\ncurl -L https://get.daocloud.io/docker/compose/releases/download/v2.4.1/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose\n\n# 修改执行权限\nsudo chmod +x /usr/local/bin/docker-compose\n\n# 创建软连接\nsudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<h2 id=\"clickhouse-对应的-docker-compose-yaml\"><a href=\"#clickhouse-对应的-docker-compose-yaml\" class=\"headerlink\" title=\"clickhouse 对应的 docker-compose.yaml\"></a>clickhouse 对应的 docker-compose.yaml</h2><ul>\n<li>指定配置文件起服务：<br><code>docker-compose -f ./xxx.yaml up -d</code>   </li>\n<li>不指定文件名称，会在当前文件夹下找 <code>docker-compose.yaml</code> 文件，进行编译<br><code>docker-compose up -d</code></li>\n</ul>\n<pre class=\"line-numbers language-yaml\"><code class=\"language-yaml\"><span class=\"token comment\" spellcheck=\"true\"># ClickHouse Document: https://clickhouse.com/docs/en/</span>\n<span class=\"token comment\" spellcheck=\"true\"># ClickHouse Docker Hub: https://hub.docker.com/r/yandex/clickhouse-server</span>\n<span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">clickhouse</span><span class=\"token punctuation\">:</span> <span class=\"token comment\" spellcheck=\"true\"># 服务名称，可以多个</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> yandex/clickhouse<span class=\"token punctuation\">-</span>server<span class=\"token punctuation\">:</span>latest <span class=\"token comment\" spellcheck=\"true\"># 使用的镜像名称，可以是本地地址</span>\n    <span class=\"token key atrule\">container_name</span><span class=\"token punctuation\">:</span> clickhouse<span class=\"token punctuation\">-</span>server <span class=\"token comment\" spellcheck=\"true\"># 容器名称</span>\n    <span class=\"token key atrule\">restart</span><span class=\"token punctuation\">:</span> always\n    <span class=\"token key atrule\">ulimits</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">nofile</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">soft</span><span class=\"token punctuation\">:</span> <span class=\"token number\">262144</span>\n        <span class=\"token key atrule\">hard</span><span class=\"token punctuation\">:</span> <span class=\"token number\">262144</span>\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span> <span class=\"token comment\" spellcheck=\"true\"># 端口映射</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token string\">\"8123:8123\"</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token string\">\"9000:9000\"</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token string\">\"9009:9009\"</span>\n    <span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span> <span class=\"token comment\" spellcheck=\"true\"># 数据映射</span>\n      <span class=\"token punctuation\">-</span> /data/clickhouse/data<span class=\"token punctuation\">:</span>/var/lib/clickhouse<span class=\"token punctuation\">:</span>rw \n      <span class=\"token punctuation\">-</span> /data/clickhouse/log<span class=\"token punctuation\">:</span>/var/log/clickhouse<span class=\"token punctuation\">-</span>server<span class=\"token punctuation\">:</span>rw\n      <span class=\"token punctuation\">-</span> /data/clickhouse/config/config.xml<span class=\"token punctuation\">:</span>/etc/clickhouse<span class=\"token punctuation\">-</span>server/config.xml\n      <span class=\"token punctuation\">-</span> /data/clickhouse/config/users.xml<span class=\"token punctuation\">:</span>/etc/clickhouse<span class=\"token punctuation\">-</span>server/users.xml\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"docker-compose-安装\"><a href=\"#docker-compose-安装\" class=\"headerlink\" title=\"docker-compose 安装\"></a>docker-compose 安装</h2><pre><code class=\"shell\"># linux 安装 docker-compose\ncurl -L https://get.daocloud.io/docker/compose/releases/download/v2.4.1/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose\n\n# 修改执行权限\nsudo chmod +x /usr/local/bin/docker-compose\n\n# 创建软连接\nsudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose\n</code></pre>\n<h2 id=\"clickhouse-对应的-docker-compose-yaml\"><a href=\"#clickhouse-对应的-docker-compose-yaml\" class=\"headerlink\" title=\"clickhouse 对应的 docker-compose.yaml\"></a>clickhouse 对应的 docker-compose.yaml</h2><ul>\n<li>指定配置文件起服务：<br><code>docker-compose -f ./xxx.yaml up -d</code>   </li>\n<li>不指定文件名称，会在当前文件夹下找 <code>docker-compose.yaml</code> 文件，进行编译<br><code>docker-compose up -d</code></li>\n</ul>\n<pre><code class=\"yaml\"># ClickHouse Document: https://clickhouse.com/docs/en/\n# ClickHouse Docker Hub: https://hub.docker.com/r/yandex/clickhouse-server\nservices:\n  clickhouse: # 服务名称，可以多个\n    image: yandex/clickhouse-server:latest # 使用的镜像名称，可以是本地地址\n    container_name: clickhouse-server # 容器名称\n    restart: always\n    ulimits:\n      nofile:\n        soft: 262144\n        hard: 262144\n    ports: # 端口映射\n      - &quot;8123:8123&quot;\n      - &quot;9000:9000&quot;\n      - &quot;9009:9009&quot;\n    volumes: # 数据映射\n      - /data/clickhouse/data:/var/lib/clickhouse:rw \n      - /data/clickhouse/log:/var/log/clickhouse-server:rw\n      - /data/clickhouse/config/config.xml:/etc/clickhouse-server/config.xml\n      - /data/clickhouse/config/users.xml:/etc/clickhouse-server/users.xml\n</code></pre>\n"},{"title":"用户状态记录的方式：Cookie、Session、Token","date":"2023-06-30T00:00:00.000Z","author":"ego","_content":"![op](../assets/img/blog/auth-op.png)    \n\n客户端和服务端进行的用户会话状态存储的机制变化，大致是：  \n    Cookie 机制(客户端存状态) => session 机制（服务端存状态） => Token（客户端存状态）。  \n\n## cookie 机制\n因为 http 请求是无状态的，就是不记录额外的信息（比如用户身份信息）。每一次的请求（客户端请求-服务端接受-服务端回应-over）是独立的，一般同一个用户发送的多次请求用的都是同一个身份，但是 http 不记录用户身份，所以服务端无法知道上一次和这一次的请求是同一个用户发送的。这时候就需要额外的机制来辅助存储用户的信息，就是 cookie。  \n一般我们所说的 cookie 包含了两层意思，一个是浏览器的 cookie 存储方式，类似 localStorage。另一个就是用来身份校验的会话状态记录机制：cookie 机制。  \ncookie 机制是基于 cookie 存储方式实现的状态记录。    \n\n###  浏览器 cookie 存储的特点 \n- 不支持跨域\n- 一些手机浏览器不支持\n- 有存储空间大小限制，4kb   \n\n### cookie 机制的流程  \n#### 首次认证    \n- 客户端：用户输入用户名和密码，发送给服务端\n- 服务端: 校验成功，返回 uid 等信息 \n- 客户端：通过 javascript 写入本地 cookie （存下 username，password（加密），uid 等信息）   \n\n#### 二次发送    \n- 客户端：发送请求，携带 cookie 信息\n- 服务端：校验成功，返回请求的结果\n- 客户端：收到结果，显示内容\n  \n  \n![auth-cookie](../assets/img/blog/auth-cookie.png)\n\n\n> cookie 机制中存在的问题是：  \n> 1. 每次浏览器都要校验用户名和密码，需要查库验证，每次都要传用户名和密码\n> 2. 受限于 cookie 的存储特点：不能跨域，有些手机不支持，大小有限制    \n\n\n## session 机制\n因为 cookie 机制每次都要验证的问题，诞生了基于 cookie 存储结构的 session 机制。 session，翻译过来就是会话的意思。\n\n### session 机制流程\n\n首次认证    \n- 客户端：用户输入用户名和密码，发送给服务端\n- 服务端：校验通过后生成 session 信息，包含 sessionId 和 sessionValue（一般包含用户的基本信息，uid,tier，expireTime 等）,设置了过期时间的 session 会在过期后自动删除。\n- 服务端：返回的 http response header 中设置 `Set-Cookie:sessionId=xx` ，然后客户端收到响应，客户端的 cookie 里就多了一条 sessionId。\n\n二次发送    \n- 客户端：用户二次访问，配置请求的连接带上 cookie 信息，就会在 request 的 header 里面多一条 `Cookie:sessionId=xx`\n- 服务端：收到 sessionId，在存的 session 信息中找 sessionId 对应的 sessionValue。\n- 服务端：拿到用户 sessionValue 中的 uid ，直接就可以使用 uid 访问数据库的资源，不用二次验证 用户名和密码\n- 服务端：返回资源\n\n\n![auth-session](../assets/img/blog/auth-session.png)\n### 什么时候需要 redis ?  \n> redis 是一个数据库，以 `key:value` 的形式存储数据。  \n在上述流程中，一个服务生成的 session 信息只存储在那个服务的内存中，但是实际应用中，一般会起很多个服务来响应用户的需求，用户的请求如果下次打到另一个服务上，那个服务没有 session 信息就会需要重新登录，所以一般情况下，会将 session 存储在额外的服务中，类似数据库，多个服务都可以连接到这个库中，查询 session 的信息是否存在，完成共享，一般情况下，session 的外部存储大多用的是 redis。\n\n\n> 所以可以看到 session 机制中存在的问题是：\n> 1. 受限于 cookie 存储特点：不能跨域，有些手机不支持，大小有限制  \n> 2. 需要存储空间（内存或者额外的数据库，比如 redis），相应的，可能就需要额外的查库时间\n\n## Token（JWT） 机制\nsession 机制很好的解决了 cookie 机制的第一个问题，但仍然是建立在 cookie 存储方式上的一种会话状态存储机制，cookie 存储的缺点仍然在：如不能跨域，有些手机不支持，大小有限制，甚至有 CSRF 攻击的风险。所以诞生了一种 Token 机制，其中 JWT 是普遍认同的 Token 机制中较优的一种。\n\n下面是一个 token 机制流程，主要用的 jwt 的结构。\n\n### token 机制流程\n首次验证  \n- 客户端：发送用户名和密码\n- 服务端：验证通过，生成 jwt 格式的 token 返回给客户端，token 包含一些用户信息，比如 uid\n- 客户端：存储 token，可以用  `cookie/localStorage/sessionStorage`  等存储    \n二次发送  \n- 客户端：将 token 放到 http 请求的 `Authorization` 字段中，传给服务器\n- 服务端：解析 token 是否正确有效，通过后根据 token 中的用户信息 uid 等进行后续资源访问，获取请求结果\n- 客户端：收到结果，显示  \n\n![auth-token](../assets/img/blog/auth-token.png)\n\n### token 优势\n可以看到 token 的方式解决了 cookie 机制和 session 机制中的几个问题：\n- 可以不用 cookie 的方式存储，可以存在 localStorage 等，相应的不能跨域、大小限制、安全问题，客户端不支持等问题也相应的解决了\n- 服务端不用额外存储用户信息，减少了内存或者数据库（存储和查询）开销  \n\n### JWT（[JSON Web Token](https://jwt.io/introduction)）\nJWT 是 Token 机制中一种较优的存储结构。大致结构是 `xxxxx.yyyyy.zzzzz` 这样的，代表了 `header.payload.signature`，具体结构介绍可以点 [这里](https://jwt.io/introduction)，一段 jwt 结构的 token，也可以在 [官网](https://jwt.io/) 解析出来。\n\n\n## 参考\n- [傻傻分不清之 Cookie、Session、Token、JWT](https://juejin.cn/post/6844904034181070861#heading-6)   \n- [Cookie与Session机制](https://zhuanlan.zhihu.com/p/21275207)     \n- [ JWT ](https://jwt.io/)\n","source":"_posts/2023-06-30-Authorization.md","raw":"---\ntitle: 用户状态记录的方式：Cookie、Session、Token\ndate: 2023-06-30 8:00:00 +0800\ncategories: [文章, auth]\ntags: [Cookie,Session,Token,jwt]\nauthor: ego\n---\n![op](../assets/img/blog/auth-op.png)    \n\n客户端和服务端进行的用户会话状态存储的机制变化，大致是：  \n    Cookie 机制(客户端存状态) => session 机制（服务端存状态） => Token（客户端存状态）。  \n\n## cookie 机制\n因为 http 请求是无状态的，就是不记录额外的信息（比如用户身份信息）。每一次的请求（客户端请求-服务端接受-服务端回应-over）是独立的，一般同一个用户发送的多次请求用的都是同一个身份，但是 http 不记录用户身份，所以服务端无法知道上一次和这一次的请求是同一个用户发送的。这时候就需要额外的机制来辅助存储用户的信息，就是 cookie。  \n一般我们所说的 cookie 包含了两层意思，一个是浏览器的 cookie 存储方式，类似 localStorage。另一个就是用来身份校验的会话状态记录机制：cookie 机制。  \ncookie 机制是基于 cookie 存储方式实现的状态记录。    \n\n###  浏览器 cookie 存储的特点 \n- 不支持跨域\n- 一些手机浏览器不支持\n- 有存储空间大小限制，4kb   \n\n### cookie 机制的流程  \n#### 首次认证    \n- 客户端：用户输入用户名和密码，发送给服务端\n- 服务端: 校验成功，返回 uid 等信息 \n- 客户端：通过 javascript 写入本地 cookie （存下 username，password（加密），uid 等信息）   \n\n#### 二次发送    \n- 客户端：发送请求，携带 cookie 信息\n- 服务端：校验成功，返回请求的结果\n- 客户端：收到结果，显示内容\n  \n  \n![auth-cookie](../assets/img/blog/auth-cookie.png)\n\n\n> cookie 机制中存在的问题是：  \n> 1. 每次浏览器都要校验用户名和密码，需要查库验证，每次都要传用户名和密码\n> 2. 受限于 cookie 的存储特点：不能跨域，有些手机不支持，大小有限制    \n\n\n## session 机制\n因为 cookie 机制每次都要验证的问题，诞生了基于 cookie 存储结构的 session 机制。 session，翻译过来就是会话的意思。\n\n### session 机制流程\n\n首次认证    \n- 客户端：用户输入用户名和密码，发送给服务端\n- 服务端：校验通过后生成 session 信息，包含 sessionId 和 sessionValue（一般包含用户的基本信息，uid,tier，expireTime 等）,设置了过期时间的 session 会在过期后自动删除。\n- 服务端：返回的 http response header 中设置 `Set-Cookie:sessionId=xx` ，然后客户端收到响应，客户端的 cookie 里就多了一条 sessionId。\n\n二次发送    \n- 客户端：用户二次访问，配置请求的连接带上 cookie 信息，就会在 request 的 header 里面多一条 `Cookie:sessionId=xx`\n- 服务端：收到 sessionId，在存的 session 信息中找 sessionId 对应的 sessionValue。\n- 服务端：拿到用户 sessionValue 中的 uid ，直接就可以使用 uid 访问数据库的资源，不用二次验证 用户名和密码\n- 服务端：返回资源\n\n\n![auth-session](../assets/img/blog/auth-session.png)\n### 什么时候需要 redis ?  \n> redis 是一个数据库，以 `key:value` 的形式存储数据。  \n在上述流程中，一个服务生成的 session 信息只存储在那个服务的内存中，但是实际应用中，一般会起很多个服务来响应用户的需求，用户的请求如果下次打到另一个服务上，那个服务没有 session 信息就会需要重新登录，所以一般情况下，会将 session 存储在额外的服务中，类似数据库，多个服务都可以连接到这个库中，查询 session 的信息是否存在，完成共享，一般情况下，session 的外部存储大多用的是 redis。\n\n\n> 所以可以看到 session 机制中存在的问题是：\n> 1. 受限于 cookie 存储特点：不能跨域，有些手机不支持，大小有限制  \n> 2. 需要存储空间（内存或者额外的数据库，比如 redis），相应的，可能就需要额外的查库时间\n\n## Token（JWT） 机制\nsession 机制很好的解决了 cookie 机制的第一个问题，但仍然是建立在 cookie 存储方式上的一种会话状态存储机制，cookie 存储的缺点仍然在：如不能跨域，有些手机不支持，大小有限制，甚至有 CSRF 攻击的风险。所以诞生了一种 Token 机制，其中 JWT 是普遍认同的 Token 机制中较优的一种。\n\n下面是一个 token 机制流程，主要用的 jwt 的结构。\n\n### token 机制流程\n首次验证  \n- 客户端：发送用户名和密码\n- 服务端：验证通过，生成 jwt 格式的 token 返回给客户端，token 包含一些用户信息，比如 uid\n- 客户端：存储 token，可以用  `cookie/localStorage/sessionStorage`  等存储    \n二次发送  \n- 客户端：将 token 放到 http 请求的 `Authorization` 字段中，传给服务器\n- 服务端：解析 token 是否正确有效，通过后根据 token 中的用户信息 uid 等进行后续资源访问，获取请求结果\n- 客户端：收到结果，显示  \n\n![auth-token](../assets/img/blog/auth-token.png)\n\n### token 优势\n可以看到 token 的方式解决了 cookie 机制和 session 机制中的几个问题：\n- 可以不用 cookie 的方式存储，可以存在 localStorage 等，相应的不能跨域、大小限制、安全问题，客户端不支持等问题也相应的解决了\n- 服务端不用额外存储用户信息，减少了内存或者数据库（存储和查询）开销  \n\n### JWT（[JSON Web Token](https://jwt.io/introduction)）\nJWT 是 Token 机制中一种较优的存储结构。大致结构是 `xxxxx.yyyyy.zzzzz` 这样的，代表了 `header.payload.signature`，具体结构介绍可以点 [这里](https://jwt.io/introduction)，一段 jwt 结构的 token，也可以在 [官网](https://jwt.io/) 解析出来。\n\n\n## 参考\n- [傻傻分不清之 Cookie、Session、Token、JWT](https://juejin.cn/post/6844904034181070861#heading-6)   \n- [Cookie与Session机制](https://zhuanlan.zhihu.com/p/21275207)     \n- [ JWT ](https://jwt.io/)\n","slug":"2023-06-30-Authorization","published":1,"updated":"2023-07-07T12:32:01.419Z","_id":"cljsj5zke0009jaf91shxdis2","comments":1,"layout":"post","photos":[],"link":"","content":"<p><img src=\"/../assets/img/blog/auth-op.png\" alt=\"op\">    </p>\n<p>客户端和服务端进行的用户会话状态存储的机制变化，大致是：<br>    Cookie 机制(客户端存状态) &#x3D;&gt; session 机制（服务端存状态） &#x3D;&gt; Token（客户端存状态）。  </p>\n<h2 id=\"cookie-机制\"><a href=\"#cookie-机制\" class=\"headerlink\" title=\"cookie 机制\"></a>cookie 机制</h2><p>因为 http 请求是无状态的，就是不记录额外的信息（比如用户身份信息）。每一次的请求（客户端请求-服务端接受-服务端回应-over）是独立的，一般同一个用户发送的多次请求用的都是同一个身份，但是 http 不记录用户身份，所以服务端无法知道上一次和这一次的请求是同一个用户发送的。这时候就需要额外的机制来辅助存储用户的信息，就是 cookie。<br>一般我们所说的 cookie 包含了两层意思，一个是浏览器的 cookie 存储方式，类似 localStorage。另一个就是用来身份校验的会话状态记录机制：cookie 机制。<br>cookie 机制是基于 cookie 存储方式实现的状态记录。    </p>\n<h3 id=\"浏览器-cookie-存储的特点\"><a href=\"#浏览器-cookie-存储的特点\" class=\"headerlink\" title=\"浏览器 cookie 存储的特点\"></a>浏览器 cookie 存储的特点</h3><ul>\n<li>不支持跨域</li>\n<li>一些手机浏览器不支持</li>\n<li>有存储空间大小限制，4kb</li>\n</ul>\n<h3 id=\"cookie-机制的流程\"><a href=\"#cookie-机制的流程\" class=\"headerlink\" title=\"cookie 机制的流程\"></a>cookie 机制的流程</h3><h4 id=\"首次认证\"><a href=\"#首次认证\" class=\"headerlink\" title=\"首次认证\"></a>首次认证</h4><ul>\n<li>客户端：用户输入用户名和密码，发送给服务端</li>\n<li>服务端: 校验成功，返回 uid 等信息 </li>\n<li>客户端：通过 javascript 写入本地 cookie （存下 username，password（加密），uid 等信息）</li>\n</ul>\n<h4 id=\"二次发送\"><a href=\"#二次发送\" class=\"headerlink\" title=\"二次发送\"></a>二次发送</h4><ul>\n<li>客户端：发送请求，携带 cookie 信息</li>\n<li>服务端：校验成功，返回请求的结果</li>\n<li>客户端：收到结果，显示内容</li>\n</ul>\n<p><img src=\"/../assets/img/blog/auth-cookie.png\" alt=\"auth-cookie\"></p>\n<blockquote>\n<p>cookie 机制中存在的问题是：  </p>\n<ol>\n<li>每次浏览器都要校验用户名和密码，需要查库验证，每次都要传用户名和密码</li>\n<li>受限于 cookie 的存储特点：不能跨域，有些手机不支持，大小有限制</li>\n</ol>\n</blockquote>\n<h2 id=\"session-机制\"><a href=\"#session-机制\" class=\"headerlink\" title=\"session 机制\"></a>session 机制</h2><p>因为 cookie 机制每次都要验证的问题，诞生了基于 cookie 存储结构的 session 机制。 session，翻译过来就是会话的意思。</p>\n<h3 id=\"session-机制流程\"><a href=\"#session-机制流程\" class=\"headerlink\" title=\"session 机制流程\"></a>session 机制流程</h3><p>首次认证    </p>\n<ul>\n<li>客户端：用户输入用户名和密码，发送给服务端</li>\n<li>服务端：校验通过后生成 session 信息，包含 sessionId 和 sessionValue（一般包含用户的基本信息，uid,tier，expireTime 等）,设置了过期时间的 session 会在过期后自动删除。</li>\n<li>服务端：返回的 http response header 中设置 <code>Set-Cookie:sessionId=xx</code> ，然后客户端收到响应，客户端的 cookie 里就多了一条 sessionId。</li>\n</ul>\n<p>二次发送    </p>\n<ul>\n<li>客户端：用户二次访问，配置请求的连接带上 cookie 信息，就会在 request 的 header 里面多一条 <code>Cookie:sessionId=xx</code></li>\n<li>服务端：收到 sessionId，在存的 session 信息中找 sessionId 对应的 sessionValue。</li>\n<li>服务端：拿到用户 sessionValue 中的 uid ，直接就可以使用 uid 访问数据库的资源，不用二次验证 用户名和密码</li>\n<li>服务端：返回资源</li>\n</ul>\n<p><img src=\"/../assets/img/blog/auth-session.png\" alt=\"auth-session\"></p>\n<h3 id=\"什么时候需要-redis\"><a href=\"#什么时候需要-redis\" class=\"headerlink\" title=\"什么时候需要 redis ?\"></a>什么时候需要 redis ?</h3><blockquote>\n<p>redis 是一个数据库，以 <code>key:value</code> 的形式存储数据。<br>在上述流程中，一个服务生成的 session 信息只存储在那个服务的内存中，但是实际应用中，一般会起很多个服务来响应用户的需求，用户的请求如果下次打到另一个服务上，那个服务没有 session 信息就会需要重新登录，所以一般情况下，会将 session 存储在额外的服务中，类似数据库，多个服务都可以连接到这个库中，查询 session 的信息是否存在，完成共享，一般情况下，session 的外部存储大多用的是 redis。</p>\n</blockquote>\n<blockquote>\n<p>所以可以看到 session 机制中存在的问题是：</p>\n<ol>\n<li>受限于 cookie 存储特点：不能跨域，有些手机不支持，大小有限制  </li>\n<li>需要存储空间（内存或者额外的数据库，比如 redis），相应的，可能就需要额外的查库时间</li>\n</ol>\n</blockquote>\n<h2 id=\"Token（JWT）-机制\"><a href=\"#Token（JWT）-机制\" class=\"headerlink\" title=\"Token（JWT） 机制\"></a>Token（JWT） 机制</h2><p>session 机制很好的解决了 cookie 机制的第一个问题，但仍然是建立在 cookie 存储方式上的一种会话状态存储机制，cookie 存储的缺点仍然在：如不能跨域，有些手机不支持，大小有限制，甚至有 CSRF 攻击的风险。所以诞生了一种 Token 机制，其中 JWT 是普遍认同的 Token 机制中较优的一种。</p>\n<p>下面是一个 token 机制流程，主要用的 jwt 的结构。</p>\n<h3 id=\"token-机制流程\"><a href=\"#token-机制流程\" class=\"headerlink\" title=\"token 机制流程\"></a>token 机制流程</h3><p>首次验证  </p>\n<ul>\n<li>客户端：发送用户名和密码</li>\n<li>服务端：验证通过，生成 jwt 格式的 token 返回给客户端，token 包含一些用户信息，比如 uid</li>\n<li>客户端：存储 token，可以用  <code>cookie/localStorage/sessionStorage</code>  等存储<br>二次发送  </li>\n<li>客户端：将 token 放到 http 请求的 <code>Authorization</code> 字段中，传给服务器</li>\n<li>服务端：解析 token 是否正确有效，通过后根据 token 中的用户信息 uid 等进行后续资源访问，获取请求结果</li>\n<li>客户端：收到结果，显示</li>\n</ul>\n<p><img src=\"/../assets/img/blog/auth-token.png\" alt=\"auth-token\"></p>\n<h3 id=\"token-优势\"><a href=\"#token-优势\" class=\"headerlink\" title=\"token 优势\"></a>token 优势</h3><p>可以看到 token 的方式解决了 cookie 机制和 session 机制中的几个问题：</p>\n<ul>\n<li>可以不用 cookie 的方式存储，可以存在 localStorage 等，相应的不能跨域、大小限制、安全问题，客户端不支持等问题也相应的解决了</li>\n<li>服务端不用额外存储用户信息，减少了内存或者数据库（存储和查询）开销</li>\n</ul>\n<h3 id=\"JWT（JSON-Web-Token）\"><a href=\"#JWT（JSON-Web-Token）\" class=\"headerlink\" title=\"JWT（JSON Web Token）\"></a>JWT（<a href=\"https://jwt.io/introduction\">JSON Web Token</a>）</h3><p>JWT 是 Token 机制中一种较优的存储结构。大致结构是 <code>xxxxx.yyyyy.zzzzz</code> 这样的，代表了 <code>header.payload.signature</code>，具体结构介绍可以点 <a href=\"https://jwt.io/introduction\">这里</a>，一段 jwt 结构的 token，也可以在 <a href=\"https://jwt.io/\">官网</a> 解析出来。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://juejin.cn/post/6844904034181070861#heading-6\">傻傻分不清之 Cookie、Session、Token、JWT</a>   </li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/21275207\">Cookie与Session机制</a>     </li>\n<li><a href=\"https://jwt.io/\"> JWT </a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"/../assets/img/blog/auth-op.png\" alt=\"op\">    </p>\n<p>客户端和服务端进行的用户会话状态存储的机制变化，大致是：<br>    Cookie 机制(客户端存状态) &#x3D;&gt; session 机制（服务端存状态） &#x3D;&gt; Token（客户端存状态）。  </p>\n<h2 id=\"cookie-机制\"><a href=\"#cookie-机制\" class=\"headerlink\" title=\"cookie 机制\"></a>cookie 机制</h2><p>因为 http 请求是无状态的，就是不记录额外的信息（比如用户身份信息）。每一次的请求（客户端请求-服务端接受-服务端回应-over）是独立的，一般同一个用户发送的多次请求用的都是同一个身份，但是 http 不记录用户身份，所以服务端无法知道上一次和这一次的请求是同一个用户发送的。这时候就需要额外的机制来辅助存储用户的信息，就是 cookie。<br>一般我们所说的 cookie 包含了两层意思，一个是浏览器的 cookie 存储方式，类似 localStorage。另一个就是用来身份校验的会话状态记录机制：cookie 机制。<br>cookie 机制是基于 cookie 存储方式实现的状态记录。    </p>\n<h3 id=\"浏览器-cookie-存储的特点\"><a href=\"#浏览器-cookie-存储的特点\" class=\"headerlink\" title=\"浏览器 cookie 存储的特点\"></a>浏览器 cookie 存储的特点</h3><ul>\n<li>不支持跨域</li>\n<li>一些手机浏览器不支持</li>\n<li>有存储空间大小限制，4kb</li>\n</ul>\n<h3 id=\"cookie-机制的流程\"><a href=\"#cookie-机制的流程\" class=\"headerlink\" title=\"cookie 机制的流程\"></a>cookie 机制的流程</h3><h4 id=\"首次认证\"><a href=\"#首次认证\" class=\"headerlink\" title=\"首次认证\"></a>首次认证</h4><ul>\n<li>客户端：用户输入用户名和密码，发送给服务端</li>\n<li>服务端: 校验成功，返回 uid 等信息 </li>\n<li>客户端：通过 javascript 写入本地 cookie （存下 username，password（加密），uid 等信息）</li>\n</ul>\n<h4 id=\"二次发送\"><a href=\"#二次发送\" class=\"headerlink\" title=\"二次发送\"></a>二次发送</h4><ul>\n<li>客户端：发送请求，携带 cookie 信息</li>\n<li>服务端：校验成功，返回请求的结果</li>\n<li>客户端：收到结果，显示内容</li>\n</ul>\n<p><img src=\"/../assets/img/blog/auth-cookie.png\" alt=\"auth-cookie\"></p>\n<blockquote>\n<p>cookie 机制中存在的问题是：  </p>\n<ol>\n<li>每次浏览器都要校验用户名和密码，需要查库验证，每次都要传用户名和密码</li>\n<li>受限于 cookie 的存储特点：不能跨域，有些手机不支持，大小有限制</li>\n</ol>\n</blockquote>\n<h2 id=\"session-机制\"><a href=\"#session-机制\" class=\"headerlink\" title=\"session 机制\"></a>session 机制</h2><p>因为 cookie 机制每次都要验证的问题，诞生了基于 cookie 存储结构的 session 机制。 session，翻译过来就是会话的意思。</p>\n<h3 id=\"session-机制流程\"><a href=\"#session-机制流程\" class=\"headerlink\" title=\"session 机制流程\"></a>session 机制流程</h3><p>首次认证    </p>\n<ul>\n<li>客户端：用户输入用户名和密码，发送给服务端</li>\n<li>服务端：校验通过后生成 session 信息，包含 sessionId 和 sessionValue（一般包含用户的基本信息，uid,tier，expireTime 等）,设置了过期时间的 session 会在过期后自动删除。</li>\n<li>服务端：返回的 http response header 中设置 <code>Set-Cookie:sessionId=xx</code> ，然后客户端收到响应，客户端的 cookie 里就多了一条 sessionId。</li>\n</ul>\n<p>二次发送    </p>\n<ul>\n<li>客户端：用户二次访问，配置请求的连接带上 cookie 信息，就会在 request 的 header 里面多一条 <code>Cookie:sessionId=xx</code></li>\n<li>服务端：收到 sessionId，在存的 session 信息中找 sessionId 对应的 sessionValue。</li>\n<li>服务端：拿到用户 sessionValue 中的 uid ，直接就可以使用 uid 访问数据库的资源，不用二次验证 用户名和密码</li>\n<li>服务端：返回资源</li>\n</ul>\n<p><img src=\"/../assets/img/blog/auth-session.png\" alt=\"auth-session\"></p>\n<h3 id=\"什么时候需要-redis\"><a href=\"#什么时候需要-redis\" class=\"headerlink\" title=\"什么时候需要 redis ?\"></a>什么时候需要 redis ?</h3><blockquote>\n<p>redis 是一个数据库，以 <code>key:value</code> 的形式存储数据。<br>在上述流程中，一个服务生成的 session 信息只存储在那个服务的内存中，但是实际应用中，一般会起很多个服务来响应用户的需求，用户的请求如果下次打到另一个服务上，那个服务没有 session 信息就会需要重新登录，所以一般情况下，会将 session 存储在额外的服务中，类似数据库，多个服务都可以连接到这个库中，查询 session 的信息是否存在，完成共享，一般情况下，session 的外部存储大多用的是 redis。</p>\n</blockquote>\n<blockquote>\n<p>所以可以看到 session 机制中存在的问题是：</p>\n<ol>\n<li>受限于 cookie 存储特点：不能跨域，有些手机不支持，大小有限制  </li>\n<li>需要存储空间（内存或者额外的数据库，比如 redis），相应的，可能就需要额外的查库时间</li>\n</ol>\n</blockquote>\n<h2 id=\"Token（JWT）-机制\"><a href=\"#Token（JWT）-机制\" class=\"headerlink\" title=\"Token（JWT） 机制\"></a>Token（JWT） 机制</h2><p>session 机制很好的解决了 cookie 机制的第一个问题，但仍然是建立在 cookie 存储方式上的一种会话状态存储机制，cookie 存储的缺点仍然在：如不能跨域，有些手机不支持，大小有限制，甚至有 CSRF 攻击的风险。所以诞生了一种 Token 机制，其中 JWT 是普遍认同的 Token 机制中较优的一种。</p>\n<p>下面是一个 token 机制流程，主要用的 jwt 的结构。</p>\n<h3 id=\"token-机制流程\"><a href=\"#token-机制流程\" class=\"headerlink\" title=\"token 机制流程\"></a>token 机制流程</h3><p>首次验证  </p>\n<ul>\n<li>客户端：发送用户名和密码</li>\n<li>服务端：验证通过，生成 jwt 格式的 token 返回给客户端，token 包含一些用户信息，比如 uid</li>\n<li>客户端：存储 token，可以用  <code>cookie/localStorage/sessionStorage</code>  等存储<br>二次发送  </li>\n<li>客户端：将 token 放到 http 请求的 <code>Authorization</code> 字段中，传给服务器</li>\n<li>服务端：解析 token 是否正确有效，通过后根据 token 中的用户信息 uid 等进行后续资源访问，获取请求结果</li>\n<li>客户端：收到结果，显示</li>\n</ul>\n<p><img src=\"/../assets/img/blog/auth-token.png\" alt=\"auth-token\"></p>\n<h3 id=\"token-优势\"><a href=\"#token-优势\" class=\"headerlink\" title=\"token 优势\"></a>token 优势</h3><p>可以看到 token 的方式解决了 cookie 机制和 session 机制中的几个问题：</p>\n<ul>\n<li>可以不用 cookie 的方式存储，可以存在 localStorage 等，相应的不能跨域、大小限制、安全问题，客户端不支持等问题也相应的解决了</li>\n<li>服务端不用额外存储用户信息，减少了内存或者数据库（存储和查询）开销</li>\n</ul>\n<h3 id=\"JWT（JSON-Web-Token）\"><a href=\"#JWT（JSON-Web-Token）\" class=\"headerlink\" title=\"JWT（JSON Web Token）\"></a>JWT（<a href=\"https://jwt.io/introduction\">JSON Web Token</a>）</h3><p>JWT 是 Token 机制中一种较优的存储结构。大致结构是 <code>xxxxx.yyyyy.zzzzz</code> 这样的，代表了 <code>header.payload.signature</code>，具体结构介绍可以点 <a href=\"https://jwt.io/introduction\">这里</a>，一段 jwt 结构的 token，也可以在 <a href=\"https://jwt.io/\">官网</a> 解析出来。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><ul>\n<li><a href=\"https://juejin.cn/post/6844904034181070861#heading-6\">傻傻分不清之 Cookie、Session、Token、JWT</a>   </li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/21275207\">Cookie与Session机制</a>     </li>\n<li><a href=\"https://jwt.io/\"> JWT </a></li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cljsj5zkd0008jaf9bzk76dx4","category_id":"cljsj5zk70004jaf91v06d9uf","_id":"cljsj5zkl000ljaf92u6ehfrn"},{"post_id":"cljsj5zkd0008jaf9bzk76dx4","category_id":"cljsj5zkj000fjaf9cjfe7eni","_id":"cljsj5zkl000njaf9dbvn8otl"},{"post_id":"cljsj5zk10001jaf9amu6h3os","category_id":"cljsj5zk70004jaf91v06d9uf","_id":"cljsj5zkm000pjaf92mqge73j"},{"post_id":"cljsj5zk10001jaf9amu6h3os","category_id":"cljsj5zkk000ijaf94mck9zcz","_id":"cljsj5zkn000sjaf985nd3pd6"},{"post_id":"cljsj5zke0009jaf91shxdis2","category_id":"cljsj5zk70004jaf91v06d9uf","_id":"cljsj5zkn000vjaf9f892cllk"},{"post_id":"cljsj5zke0009jaf91shxdis2","category_id":"cljsj5zkl000mjaf94ht201sm","_id":"cljsj5zko000yjaf93pkyflsz"},{"post_id":"cljsj5zk50003jaf9g6jr295i","category_id":"cljsj5zk70004jaf91v06d9uf","_id":"cljsj5zko0010jaf9beey08o2"},{"post_id":"cljsj5zk50003jaf9g6jr295i","category_id":"cljsj5zkj000fjaf9cjfe7eni","_id":"cljsj5zko0011jaf93c652jj2"},{"post_id":"cljsj5zka0006jaf97vnyf429","category_id":"cljsj5zk70004jaf91v06d9uf","_id":"cljsj5zko0013jaf9epsz09o9"},{"post_id":"cljsj5zka0006jaf97vnyf429","category_id":"cljsj5zkj000fjaf9cjfe7eni","_id":"cljsj5zkp0014jaf98bca95yc"}],"PostTag":[{"post_id":"cljsj5zk50003jaf9g6jr295i","tag_id":"cljsj5zkc0007jaf92j6mdoho","_id":"cljsj5zki000cjaf95rl61p10"},{"post_id":"cljsj5zka0006jaf97vnyf429","tag_id":"cljsj5zkc0007jaf92j6mdoho","_id":"cljsj5zkk000hjaf95j8bc1a3"},{"post_id":"cljsj5zka0006jaf97vnyf429","tag_id":"cljsj5zkj000ejaf9hw2mht39","_id":"cljsj5zkl000jjaf9gx8qeok7"},{"post_id":"cljsj5zkd0008jaf9bzk76dx4","tag_id":"cljsj5zkc0007jaf92j6mdoho","_id":"cljsj5zkn000tjaf9hb7tgjfc"},{"post_id":"cljsj5zkd0008jaf9bzk76dx4","tag_id":"cljsj5zkl000kjaf91gyzcpu5","_id":"cljsj5zkn000wjaf90epm9yo5"},{"post_id":"cljsj5zkd0008jaf9bzk76dx4","tag_id":"cljsj5zkj000ejaf9hw2mht39","_id":"cljsj5zko000zjaf970a80id4"},{"post_id":"cljsj5zke0009jaf91shxdis2","tag_id":"cljsj5zkm000rjaf98yus7kkd","_id":"cljsj5zkp0016jaf98ofqcyp7"},{"post_id":"cljsj5zke0009jaf91shxdis2","tag_id":"cljsj5zko000xjaf971s94iro","_id":"cljsj5zkp0017jaf9hfubdgyb"},{"post_id":"cljsj5zke0009jaf91shxdis2","tag_id":"cljsj5zko0012jaf93mc004ea","_id":"cljsj5zkp0018jaf90hn31ey1"},{"post_id":"cljsj5zke0009jaf91shxdis2","tag_id":"cljsj5zkp0015jaf925yp5lby","_id":"cljsj5zkp0019jaf987ap22nb"}],"Tag":[{"name":"docker","_id":"cljsj5zkc0007jaf92j6mdoho"},{"name":"clickhouse","_id":"cljsj5zkj000ejaf9hw2mht39"},{"name":"docker-compose","_id":"cljsj5zkl000kjaf91gyzcpu5"},{"name":"Cookie","_id":"cljsj5zkm000rjaf98yus7kkd"},{"name":"Session","_id":"cljsj5zko000xjaf971s94iro"},{"name":"Token","_id":"cljsj5zko0012jaf93mc004ea"},{"name":"jwt","_id":"cljsj5zkp0015jaf925yp5lby"}]}}